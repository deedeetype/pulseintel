name: Scheduled Scan Refresh v2

on:
  schedule:
    # Run every hour at minute 0 (UTC)
    - cron: '0 * * * *'
  workflow_dispatch: # Allow manual trigger for testing

jobs:
  refresh-scans:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm install @supabase/supabase-js
      
      - name: Process scheduled refreshes
        env:
          SUPABASE_URL: https://erkzlqgpbrxokyqtrgnf.supabase.co
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
          NETLIFY_URL: https://pulseintel.netlify.app
        run: |
          node << 'NODESCRIPT'
          const { createClient } = require('@supabase/supabase-js')
          
          const supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_KEY
          )
          
          async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms))
          }
          
          async function callNetlifyFunction(step, data) {
            const response = await fetch(`${process.env.NETLIFY_URL}/.netlify/functions/scan-step`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ step, ...data })
            })
            if (!response.ok) {
              throw new Error(`${step} step failed: ${response.status}`)
            }
            return response.json()
          }
          
          async function processRefresh(scan, scheduleId) {
            console.log(`\nðŸ”„ Processing: ${scan.id.slice(0,8)} (${scan.industry})`)
            
            // Create refresh log
            const { data: logData, error: logError } = await supabase
              .from('refresh_logs')
              .insert({
                scan_id: scan.id,
                user_id: scan.user_id,
                triggered_by: 'scheduled',
                status: 'running',
                started_at: new Date().toISOString()
              })
              .select()
            
            if (logError) {
              console.error(`  âŒ Failed to create log:`, logError)
              return
            }
            
            const logId = logData[0].id
            console.log(`  ðŸ“ Log created: ${logId.slice(0,8)}`)
            
            try {
              // Step 1: Fetch competitors
              console.log(`  ðŸ‘¥ Fetching competitors...`)
              const { data: competitors } = await supabase
                .from('competitors')
                .select('name')
                .eq('scan_id', scan.id)
              
              const competitorNames = competitors?.map(c => c.name) || []
              console.log(`  âœ“ Found ${competitorNames.length} competitors`)
              
              // Step 2: Collect news
              console.log(`  ðŸ“° Collecting news...`)
              const newsResponse = await callNetlifyFunction('news', {
                industry: scan.industry
              })
              console.log(`  âœ“ Collected ${newsResponse.count || 0} news items`)
              
              // Step 3: Generate insights
              console.log(`  ðŸ’¡ Generating insights...`)
              const insightsResponse = await callNetlifyFunction('analyze-insights', {
                scanId: scan.id,
                industry: scan.industry,
                news: newsResponse.news || [],
                competitorNames,
                userId: scan.user_id
              })
              console.log(`  âœ“ Generated ${insightsResponse.count || 0} insights`)
              
              // Step 4: Generate alerts
              console.log(`  ðŸ”” Generating alerts...`)
              const alertsResponse = await callNetlifyFunction('analyze-alerts', {
                scanId: scan.id,
                industry: scan.industry,
                news: newsResponse.news || [],
                competitorNames,
                userId: scan.user_id
              })
              console.log(`  âœ“ Generated ${alertsResponse.count || 0} alerts`)
              
              // Step 5: Finalize
              console.log(`  ðŸ’¾ Finalizing...`)
              const finalizeResponse = await callNetlifyFunction('finalize', {
                scanId: scan.id,
                industry: scan.industry,
                competitors: [],
                insights: insightsResponse.insights || [],
                alerts: alertsResponse.alerts || [],
                news: newsResponse.news || [],
                isRefresh: true,
                userId: scan.user_id
              })
              
              console.log(`  âœ“ Saved: ${finalizeResponse.alerts} alerts, ${finalizeResponse.insights} insights, ${finalizeResponse.news} news`)
              
              // Mark log as success
              await supabase
                .from('refresh_logs')
                .update({
                  status: 'success',
                  completed_at: new Date().toISOString(),
                  new_alerts_count: finalizeResponse.alerts,
                  new_insights_count: finalizeResponse.insights,
                  new_news_count: finalizeResponse.news
                })
                .eq('id', logId)
              
              // Update schedule last_run_at
              await supabase
                .from('scan_schedules')
                .update({ last_run_at: new Date().toISOString() })
                .eq('id', scheduleId)
              
              console.log(`  âœ… Completed successfully`)
              
            } catch (error) {
              console.error(`  âŒ Error:`, error.message)
              
              // Mark log as failed
              await supabase
                .from('refresh_logs')
                .update({
                  status: 'failed',
                  completed_at: new Date().toISOString(),
                  error_message: error.message
                })
                .eq('id', logId)
            }
          }
          
          async function main() {
            console.log(`ðŸ¦ Starting scheduled refresh at ${new Date().toISOString()}`)
            
            // Fetch due schedules
            const { data: schedules, error: schedError } = await supabase
              .from('scan_schedules')
              .select('id, scan_id, user_id, frequency')
              .eq('enabled', true)
              .lte('next_run_at', new Date().toISOString())
            
            if (schedError) {
              console.error('Failed to fetch schedules:', schedError)
              process.exit(1)
            }
            
            console.log(`ðŸ“… Found ${schedules.length} due schedules`)
            
            if (schedules.length === 0) {
              console.log('âœ… No schedules due')
              return
            }
            
            // Fetch scan details
            const scanIds = schedules.map(s => s.scan_id)
            const { data: scans, error: scanError } = await supabase
              .from('scans')
              .select('id, user_id, industry, company_url, company_name')
              .in('id', scanIds)
            
            if (scanError) {
              console.error('Failed to fetch scans:', scanError)
              process.exit(1)
            }
            
            console.log(`ðŸ“‹ Scans to process: ${scans.length}`)
            scans.forEach(s => {
              console.log(`  - ${s.id.slice(0,8)} | ${s.industry} | ${s.company_name || 'N/A'}`)
            })
            
            // Process each scan sequentially
            for (const scan of scans) {
              const schedule = schedules.find(sch => sch.scan_id === scan.id)
              await processRefresh(scan, schedule.id)
              await sleep(2000) // Wait 2 seconds between scans
            }
            
            console.log(`\nðŸŽ‰ All scheduled refreshes completed`)
          }
          
          main().catch(err => {
            console.error('Fatal error:', err)
            process.exit(1)
          })
          NODESCRIPT
